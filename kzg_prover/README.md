# Summa V2: Polynomial Encoding Approach

## Motivation

Summa V1 was using a Merkle sum tree (MST) as the main data structure and a cryptographic commitment. MST that has $n$ leaves involves hashing operations over $2n-1$ entries, making it computationally demanding. Additionally, the MST inclusion proofs in Summa V1 have to be wrapped into a ZK-SNARK, making it computationally demanding to generate all of them at once for the entire user base of the Custodian (~100M users).

## Univariate Grand Sum Calculation

The grand total of all the Custodian's $n$ user cryptocurrency balances is the Custodian's liabilities $S$. Summa V2 is using a property of the _sum of all roots of unity in a finite field_ being _equal to zero_ to find the liabilities. This property allows to efficiently calculate the grand sum of univariate polynomial evaluations. Summa V2 takes advantage of that by encoding the user balances into a univariate polynomial in a special way. The resulting proof of solvency protocol has the following steps:

1. construct a polynomial of degree $d = n - 1$ that interpolates the points ($\omega^i$,$b_i$) where $i \in 0..n-1$ is the user index, $\omega^i$ is the power of an $n$-th primitive root of unity ($x$ value), and $b_i$ is the $i$-th user balance value ($y$ value);
2. multiply the constant term $a_0$ of the polynomial by $n$ to obtain the grand sum: $\boxed{S = a_0n= \sum_{i=0}^{n-1}b_i}$;
3. use a polynomial commitment scheme to provide opening proofs to the individual users and a public $a_0$ opening at $x=0$.

Please refer to the [article](https://hackmd.io/@summa/BkglBWsDp) for the detailed description of the algorithm.

## Algorithm Implementation

Halo2 allows to efficiently implement the described algorithm for the following reasons:

- the advice columns in Halo2 are interpolated as polynomials, and the $x$ values are the powers of a primitive root of unity;
- Halo2 is internally using a KZG polynomial commitment scheme;
- the use of a ZK-SNARK allows to additionally constrain the balance values, namely, perform the range check.

The algorithm works as follows:

1. Assign all the user balances to an unblinded advice column of the circuit. The unblinded advice column is a kind of advice column without the random values (blinding factors) added at the bottom.
2. Generate the ZK-SNARK proof for the circuit, effectively encoding the balance values into a polynomial and performing a KZG commitment to this polynomial.
3. Perform a KZG opening proof of the polynomial at $x=0$ and publicly reveal the constant term $a_0$ of the polynomial. The public can then calculate the liabilities by multiplying the $a_0$ by $d + 1$ where $d$ is the polynomial degree.
4. Privately provide to each user a KZG opening proof of the corresponding user opening.

## Usage

To build, test and print the circuits, execute

```
cargo build
cargo test --release --features dev-graph
```

## Documentation

The documentation for the circuits can be generated by running

```
cargo doc --no-deps --open
```

## Powers of Tau Trusted Setup

For testing purposes, it's not necessary to download the `ptau` file. The `generate_setup_artifacts` function can manage this by generating a new setup from a randomly generated value. This automated generation process is intended for testing and development convenience, and it should not be used in production.
For real-world situations, you must provide the path of a specific `ptau` file to the `generate_setup_artifacts`. The circuit will use the randomness from the given file. You can find an example that initializes a `Snapshot` instance [here](https://github.com/summa-dev/summa-solvency/blob/11d4fce5d18f6175804aa792fc9fc5ac27bf5c00/backend/src/apis/snapshot.rs#L115-L116) in the backend.
